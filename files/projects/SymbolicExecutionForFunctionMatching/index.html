<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/index.css">
  <title>SJCOMEAU</title>
</head>


<body>
<div class="toolbarContainer">
  <h1 class="header">SAMANTHA COMEAU</h1>
  <div class="toolbarInnerContainer">
    <h1 class="toolbar" onclick="loadPage('/index.html')">HOME</h1>
    <h1 class="toolbar" onclick="loadPage('/projects.html')">PROJECTS</h1>
    <h1 class="toolbar" onclick="loadPage('/passions.html')">ABOUT</h1>
  </div>
</div><br><br>

<div class="mainContainer">
  <h1 class="header">Symbolic Execution for Function Matching</h1>
  <h2 class="header2">DESCRIPTION</h2>
  <p> This was a part of WPI's Major Qualifying Project, a project focusing on conducting research specific to the student's degree. 
    The main goal of this project is for a student to support a company, in this case MITRE, or a professor in their research efforts. 
    For this project, I worked on my own, with help from employees at MITRE to research the potential for symbolic execution to 
    benefit an ongoing project that attempts to minimize reverse engineering efforts on malware / ransomware by automatically detecting 
    matches between functions of previously reversed binaries, to newly found binaries that need to be analyzed. </p>
  <h2 class="header2">ABSTRACT</h2>
  <p>The idea for this project was to use symbolic execution to create an architecture-agnostic representation of a function 
    to use for function matching.  We were motivated because reverse engineering is a difficult job to do because of the many 
    limitations of static analysis.  Simply looking at assembly code and attempting to determine what a function does based on 
    different inputs is difficult and time consuming.  Using symbolic execution, a reverse engineer no longer must read and 
    interpret assembly language and can rather focus on the core behavior of the function by interpreting the symbolic analysis 
    results.  Symbolic execution is a dynamic analysis method that provides the reverse engineer with a better understanding of 
    what a binary does during run-time.  Using symbolic execution for a function matcher allows for functions to be matched based 
    on how they react to symbolic variables such as parameters, memory reads and more. </p>
  <p> Our matcher uses symbolic constraints to match functions cross architecture.  This project uses angr to extract 
    symbolic information about the program and generate an architecture agnostic representation of a function. We then use 
    this representation to match functions from different binaries.  We evaluated our work using a variety of test binaries 
    compiled for different architectures and the same binary from multiple versions of a project.  Our matcher gave us upwards 
    of 87% of functions matched when it came to ideal functions for this matcher type.  Ideal functions for this matcher are 
    functions whose control flow relies on run time data.  Where we could match functions cross architecture, the leading tool 
    for function matching, BinDiff, could not.  Our proposed matcher attempts to solve the problem of cross architecture 
    comparisons of binaries while also allowing full code coverage. </p>
  <h2 class="header2">RESOURCES</h2>
  <a href="scomeau_mqp_publicallyreleased.pdf">Project Report</a>

</body>  

<script>
function loadPage(page) {
  window.location.href = page;

}
</script>
</html>
